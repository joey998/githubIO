(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{378:function(n,e,t){"use strict";t.r(e);var r=t(40),s=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"_10-原型链实现继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-原型链实现继承"}},[n._v("#")]),n._v(" 10.原型链实现继承")]),n._v(" "),t("p",[n._v("不搞那些概念性的东西，直接说结论了，实现继承的方式就是：\n"),t("em",[t("strong",[n._v("将第一个构造函数的原型等于第二个构造函数的实例，然后第一个构造函数的所有实例都会拥有第二个构造函数的所有自有属性以及原型属性")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('function Person(){\n    this.a = 1;\n    this.b = 2;\n}\nfunction PersonNext(){\n    this.shareOne = "one";\n    this.shareTwo = "two";\n}\nPersonNext.prototype.cc = function(){\n    alert(11);\n}\npNext = new PersonNext();\n\nPerson.prototype = pNext;    //将Person的原型等于PersonNext的实例,这样写会将Person的原型全部替换，之前写的原型属性都会被替换\nPerson.prototype.fa = function(){  //在替换之后写的属性才会生效\n    alert("aha!")\n}\n\nper1 = new Person();\nper1.hasOwnProperty("a");   //true\n\nper1.shareOne;    //one\nper1.hasOwnProperty("shareOne");   //false\n\nper1.cc;  //f () {alert(11)}\nper1.hasOwnProperty("cc");  //false\n\nper1.fa;  //f () {alert("aha")}\nper1.hasOwnProperty("fa");  //false\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);